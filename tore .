[1mdiff --git a/tinyhttp-codegen/Cargo.toml b/tinyhttp-codegen/Cargo.toml[m
[1mindex 9d000cd..9fb63c4 100644[m
[1m--- a/tinyhttp-codegen/Cargo.toml[m
[1m+++ b/tinyhttp-codegen/Cargo.toml[m
[36m@@ -16,4 +16,4 @@[m [mproc-macro = true[m
[dependencies][m
syn = { version = "1.0.98", features = ["full"] }[m
quote = "1.0.18"[m
tinyhttp-internal = { path = "../tinyhttp-internal", version = [31m"0.3.0" }[m[32m"0.3.0", default-features = false}[m
[1mdiff --git a/tinyhttp-internal/src/http.rs b/tinyhttp-internal/src/http.rs[m
[1mindex 709cbc4..fc206b6 100644[m
[1m--- a/tinyhttp-internal/src/http.rs[m
[1m+++ b/tinyhttp-internal/src/http.rs[m
[36m@@ -6,7 +6,7 @@[m [muse std::{[m
    path::Path,[m
    rc::Rc,[m
    time::Instant,[m
    vec, [32mborrow::BorrowMut,[m
};[m

#[cfg(not(feature = "async"))][m
[36m@@ -122,6 +122,11 @@[m [mfn build_and_parse_req(buf: Vec<u8>) -> Request {[m
    let str_status_line = Vec::from_iter(iter_status_line.split_whitespace());[m
    let status_line: Rc<Vec<String>> =[m
        Rc::new(str_status_line.iter().map(|i| String::from(*i)).collect());[m
    
    [32m/*if status_line[2].contains('?') {[m
[32m        let index = status_line[2].find('?').unwrap();[m
[32m        status_line.borrow_mut()[2] = status_line[2].drain(..index).collect();[m
[32m    }*/[m
    #[cfg(feature = "log")][m
    log::debug!("{:#?}", status_line);[m
    let body_index = buf[m
[36m@@ -230,7 +235,7 @@[m [mfn build_res(req: &mut Request, config: &Config) -> Response {[m
                    .mime("text/html"),[m
            },[m
        },[m
        "POST" => match config.post_routes(&mut [31mreq_path.borrow_mut())[m[32mreq_path.borrow())[m {
            Some(route) => {[m
                #[cfg(feature = "log")][m
                log::debug!("POST");[m
[36m@@ -269,32 +274,29 @@[m [mfn parse_request<P: Read + Write>(conn: &mut P, config: Config) {[m
    let mut request = build_and_parse_req(buf);[m

    let response = Rc::new(RefCell::new(build_res(&mut request, &config)));[m
    let mime = [31mresponse.borrow_mut().mime.clone().unwrap();[m[32mresponse.borrow().mime.clone().unwrap();[m

    let inferred_mime = match [31minfer::get(response.borrow_mut().body.as_ref().unwrap())[m[32minfer::get(response.borrow().body.as_ref().unwrap())[m {
        Some(mime) => mime.mime_type().to_string(),[m
        None => mime,[m
    };[m

    [31mmatch config.get_headers() {[m[32mif let[m Some(vec) [31m=>[m[32m= config.get_headers()[m {
        for (i, j) in vec.iter() {
            response
                .borrow_mut()
                .headers
                .insert(i.to_string(), j.to_string());[31m}[m
        }[m
[31m        None => (),[m
    }[m

    response[m
        [31m.borrow_mut()[m[32m.borrow()[m
        .headers[m
        .insert("Content-Type: ".to_string(), inferred_mime + "\r\n");[m

    response[m
        [31m.borrow_mut()[m[32m.borrow()[m
        .headers[m
        .insert("X-:)-->: ".to_string(), "HEHEHE\r\n".to_string());[m

[36m@@ -320,12 +322,12 @@[m [mfn parse_request<P: Read + Write>(conn: &mut P, config: Config) {[m
        #[cfg(feature = "log")][m
        log::debug!("GZIP ENABLED!");[m
        let start: Instant = std::time::Instant::now();[m
        let body = [31mresponse.borrow_mut().body.clone();[m[32mresponse.borrow().body.clone();[m
        let mut writer = GzEncoder::new(Vec::new(), Compression::default());[m
        writer.write_all(&body.unwrap()).unwrap();[m
        [31mresponse.borrow_mut().body[m[32mresponse.borrow().body[m = Some(writer.finish().unwrap());
        response[m
            [31m.borrow_mut()[m[32m.borrow()[m
            .headers[m
            .insert("Content-Encoding: ".to_string(), "gzip\r\n".to_string());[m
        #[cfg(feature = "log")][m
[36m@@ -334,7 +336,7 @@[m [mfn parse_request<P: Read + Write>(conn: &mut P, config: Config) {[m

    #[cfg(feature = "log")][m
    {[m
        let brw = [31mresponse.borrow_mut();[m[32mresponse.borrow();[m
        log::debug!([m
            "RESPONSE BODY: {:#?},\n RESPONSE HEADERS: {:#?}\n",[m
            brw.body.as_ref().unwrap(),[m
[36m@@ -342,7 +344,7 @@[m [mfn parse_request<P: Read + Write>(conn: &mut P, config: Config) {[m
        );[m
    }[m

    [31mresponse.borrow_mut().send(conn);[m[32mresponse.borrow().send(conn);[m
}[m

pub fn read_to_vec<P: AsRef<Path>>(path: P) -> io::Result<Vec<u8>> {[m
[1mdiff --git a/tinyhttp/src/lib.rs b/tinyhttp/src/lib.rs[m
[1mindex baeb5b1..ed94d9d 100644[m
[1m--- a/tinyhttp/src/lib.rs[m
[1m+++ b/tinyhttp/src/lib.rs[m
[36m@@ -77,6 +77,11 @@[m
//!         .mime("text/plain")[m
//!         .body(b"Hello from response!\r\n".to_vec())[m
//! }[m
[32m//! [m
[32m//! fn main() {[m
[32m//!     let routes = Routes::new(vec![ex1_get(), ex2_get(), ex3_get()]);[m
[32m//!     let config = Config::new().routes(routes);[m
[32m//! }[m

pub use tinyhttp_codegen as codegen;[m
pub use tinyhttp_internal as internal;[m
[36m@@ -91,6 +96,7 @@[m [mpub mod prelude {[m

#[cfg(test)][m
mod tests {[m

    #[test][m
    fn test_codegen() {[m
        use crate::prelude::*;[m
[36m@@ -150,5 +156,7 @@[m [mmod tests {[m
                .body[m
                .unwrap()[m
        );[m

        
    }[m
}[m
